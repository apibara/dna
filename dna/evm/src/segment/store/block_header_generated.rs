// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::cmp::Ordering;
use core::mem;
pub enum BlockHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockHeader<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockHeader<'a> {
    type Inner = BlockHeader<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> BlockHeader<'a> {
    pub const VT_NUMBER: flatbuffers::VOffsetT = 4;
    pub const VT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 8;
    pub const VT_UNCLES_HASH: flatbuffers::VOffsetT = 10;
    pub const VT_MINER: flatbuffers::VOffsetT = 12;
    pub const VT_STATE_ROOT: flatbuffers::VOffsetT = 14;
    pub const VT_TRANSACTIONS_ROOT: flatbuffers::VOffsetT = 16;
    pub const VT_RECEIPTS_ROOT: flatbuffers::VOffsetT = 18;
    pub const VT_LOGS_BLOOM: flatbuffers::VOffsetT = 20;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 22;
    pub const VT_GAS_LIMIT: flatbuffers::VOffsetT = 24;
    pub const VT_GAS_USED: flatbuffers::VOffsetT = 26;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 28;
    pub const VT_EXTRA_DATA: flatbuffers::VOffsetT = 30;
    pub const VT_MIX_HASH: flatbuffers::VOffsetT = 32;
    pub const VT_NONCE: flatbuffers::VOffsetT = 34;
    pub const VT_BASE_FEE_PER_GAS: flatbuffers::VOffsetT = 36;
    pub const VT_WITHDRAWALS_ROOT: flatbuffers::VOffsetT = 38;
    pub const VT_TOTAL_DIFFICULTY: flatbuffers::VOffsetT = 40;
    pub const VT_UNCLES: flatbuffers::VOffsetT = 42;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 44;
    pub const VT_WITHDRAWALS: flatbuffers::VOffsetT = 46;

    pub const fn get_fully_qualified_name() -> &'static str {
        "BlockHeader"
    }

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockHeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<BlockHeader<'bldr>> {
        let mut builder = BlockHeaderBuilder::new(_fbb);
        builder.add_nonce(args.nonce);
        builder.add_number(args.number);
        if let Some(x) = args.withdrawals {
            builder.add_withdrawals(x);
        }
        if let Some(x) = args.size_ {
            builder.add_size_(x);
        }
        if let Some(x) = args.uncles {
            builder.add_uncles(x);
        }
        if let Some(x) = args.total_difficulty {
            builder.add_total_difficulty(x);
        }
        if let Some(x) = args.withdrawals_root {
            builder.add_withdrawals_root(x);
        }
        if let Some(x) = args.base_fee_per_gas {
            builder.add_base_fee_per_gas(x);
        }
        if let Some(x) = args.mix_hash {
            builder.add_mix_hash(x);
        }
        if let Some(x) = args.extra_data {
            builder.add_extra_data(x);
        }
        if let Some(x) = args.timestamp {
            builder.add_timestamp(x);
        }
        if let Some(x) = args.gas_used {
            builder.add_gas_used(x);
        }
        if let Some(x) = args.gas_limit {
            builder.add_gas_limit(x);
        }
        if let Some(x) = args.difficulty {
            builder.add_difficulty(x);
        }
        if let Some(x) = args.logs_bloom {
            builder.add_logs_bloom(x);
        }
        if let Some(x) = args.receipts_root {
            builder.add_receipts_root(x);
        }
        if let Some(x) = args.transactions_root {
            builder.add_transactions_root(x);
        }
        if let Some(x) = args.state_root {
            builder.add_state_root(x);
        }
        if let Some(x) = args.miner {
            builder.add_miner(x);
        }
        if let Some(x) = args.uncles_hash {
            builder.add_uncles_hash(x);
        }
        if let Some(x) = args.parent_hash {
            builder.add_parent_hash(x);
        }
        if let Some(x) = args.hash {
            builder.add_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn number(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(BlockHeader::VT_NUMBER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn hash(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<B256>(BlockHeader::VT_HASH, None) }
    }
    #[inline]
    pub fn parent_hash(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<B256>(BlockHeader::VT_PARENT_HASH, None) }
    }
    #[inline]
    pub fn uncles_hash(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<B256>(BlockHeader::VT_UNCLES_HASH, None) }
    }
    #[inline]
    pub fn miner(&self) -> Option<&'a Address> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Address>(BlockHeader::VT_MINER, None) }
    }
    #[inline]
    pub fn state_root(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<B256>(BlockHeader::VT_STATE_ROOT, None) }
    }
    #[inline]
    pub fn transactions_root(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<B256>(BlockHeader::VT_TRANSACTIONS_ROOT, None)
        }
    }
    #[inline]
    pub fn receipts_root(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<B256>(BlockHeader::VT_RECEIPTS_ROOT, None) }
    }
    #[inline]
    pub fn logs_bloom(&self) -> Option<&'a Bloom> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Bloom>(BlockHeader::VT_LOGS_BLOOM, None) }
    }
    #[inline]
    pub fn difficulty(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<U256>(BlockHeader::VT_DIFFICULTY, None) }
    }
    #[inline]
    pub fn gas_limit(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<U256>(BlockHeader::VT_GAS_LIMIT, None) }
    }
    #[inline]
    pub fn gas_used(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<U256>(BlockHeader::VT_GAS_USED, None) }
    }
    #[inline]
    pub fn timestamp(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<U256>(BlockHeader::VT_TIMESTAMP, None) }
    }
    #[inline]
    pub fn extra_data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    BlockHeader::VT_EXTRA_DATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn mix_hash(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<B256>(BlockHeader::VT_MIX_HASH, None) }
    }
    #[inline]
    pub fn nonce(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(BlockHeader::VT_NONCE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn base_fee_per_gas(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<U256>(BlockHeader::VT_BASE_FEE_PER_GAS, None)
        }
    }
    #[inline]
    pub fn withdrawals_root(&self) -> Option<&'a B256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<B256>(BlockHeader::VT_WITHDRAWALS_ROOT, None)
        }
    }
    #[inline]
    pub fn total_difficulty(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<U256>(BlockHeader::VT_TOTAL_DIFFICULTY, None)
        }
    }
    #[inline]
    pub fn uncles(&self) -> Option<flatbuffers::Vector<'a, B256>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, B256>>>(
                    BlockHeader::VT_UNCLES,
                    None,
                )
        }
    }
    #[inline]
    pub fn size_(&self) -> Option<&'a U256> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<U256>(BlockHeader::VT_SIZE_, None) }
    }
    #[inline]
    pub fn withdrawals(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Withdrawal<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Withdrawal>>,
            >>(BlockHeader::VT_WITHDRAWALS, None)
        }
    }
}

impl flatbuffers::Verifiable for BlockHeader<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("number", Self::VT_NUMBER, false)?
            .visit_field::<B256>("hash", Self::VT_HASH, false)?
            .visit_field::<B256>("parent_hash", Self::VT_PARENT_HASH, false)?
            .visit_field::<B256>("uncles_hash", Self::VT_UNCLES_HASH, false)?
            .visit_field::<Address>("miner", Self::VT_MINER, false)?
            .visit_field::<B256>("state_root", Self::VT_STATE_ROOT, false)?
            .visit_field::<B256>("transactions_root", Self::VT_TRANSACTIONS_ROOT, false)?
            .visit_field::<B256>("receipts_root", Self::VT_RECEIPTS_ROOT, false)?
            .visit_field::<Bloom>("logs_bloom", Self::VT_LOGS_BLOOM, false)?
            .visit_field::<U256>("difficulty", Self::VT_DIFFICULTY, false)?
            .visit_field::<U256>("gas_limit", Self::VT_GAS_LIMIT, false)?
            .visit_field::<U256>("gas_used", Self::VT_GAS_USED, false)?
            .visit_field::<U256>("timestamp", Self::VT_TIMESTAMP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "extra_data",
                Self::VT_EXTRA_DATA,
                false,
            )?
            .visit_field::<B256>("mix_hash", Self::VT_MIX_HASH, false)?
            .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
            .visit_field::<U256>("base_fee_per_gas", Self::VT_BASE_FEE_PER_GAS, false)?
            .visit_field::<B256>("withdrawals_root", Self::VT_WITHDRAWALS_ROOT, false)?
            .visit_field::<U256>("total_difficulty", Self::VT_TOTAL_DIFFICULTY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, B256>>>(
                "uncles",
                Self::VT_UNCLES,
                false,
            )?
            .visit_field::<U256>("size_", Self::VT_SIZE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Withdrawal>>,
            >>("withdrawals", Self::VT_WITHDRAWALS, false)?
            .finish();
        Ok(())
    }
}
pub struct BlockHeaderArgs<'a> {
    pub number: u64,
    pub hash: Option<&'a B256>,
    pub parent_hash: Option<&'a B256>,
    pub uncles_hash: Option<&'a B256>,
    pub miner: Option<&'a Address>,
    pub state_root: Option<&'a B256>,
    pub transactions_root: Option<&'a B256>,
    pub receipts_root: Option<&'a B256>,
    pub logs_bloom: Option<&'a Bloom>,
    pub difficulty: Option<&'a U256>,
    pub gas_limit: Option<&'a U256>,
    pub gas_used: Option<&'a U256>,
    pub timestamp: Option<&'a U256>,
    pub extra_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub mix_hash: Option<&'a B256>,
    pub nonce: u64,
    pub base_fee_per_gas: Option<&'a U256>,
    pub withdrawals_root: Option<&'a B256>,
    pub total_difficulty: Option<&'a U256>,
    pub uncles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, B256>>>,
    pub size_: Option<&'a U256>,
    pub withdrawals: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Withdrawal<'a>>>,
        >,
    >,
}
impl<'a> Default for BlockHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockHeaderArgs {
            number: 0,
            hash: None,
            parent_hash: None,
            uncles_hash: None,
            miner: None,
            state_root: None,
            transactions_root: None,
            receipts_root: None,
            logs_bloom: None,
            difficulty: None,
            gas_limit: None,
            gas_used: None,
            timestamp: None,
            extra_data: None,
            mix_hash: None,
            nonce: 0,
            base_fee_per_gas: None,
            withdrawals_root: None,
            total_difficulty: None,
            uncles: None,
            size_: None,
            withdrawals: None,
        }
    }
}

pub struct BlockHeaderBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockHeaderBuilder<'a, 'b> {
    #[inline]
    pub fn add_number(&mut self, number: u64) {
        self.fbb_
            .push_slot::<u64>(BlockHeader::VT_NUMBER, number, 0);
    }
    #[inline]
    pub fn add_hash(&mut self, hash: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_HASH, hash);
    }
    #[inline]
    pub fn add_parent_hash(&mut self, parent_hash: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_PARENT_HASH, parent_hash);
    }
    #[inline]
    pub fn add_uncles_hash(&mut self, uncles_hash: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_UNCLES_HASH, uncles_hash);
    }
    #[inline]
    pub fn add_miner(&mut self, miner: &Address) {
        self.fbb_
            .push_slot_always::<&Address>(BlockHeader::VT_MINER, miner);
    }
    #[inline]
    pub fn add_state_root(&mut self, state_root: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_STATE_ROOT, state_root);
    }
    #[inline]
    pub fn add_transactions_root(&mut self, transactions_root: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_TRANSACTIONS_ROOT, transactions_root);
    }
    #[inline]
    pub fn add_receipts_root(&mut self, receipts_root: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_RECEIPTS_ROOT, receipts_root);
    }
    #[inline]
    pub fn add_logs_bloom(&mut self, logs_bloom: &Bloom) {
        self.fbb_
            .push_slot_always::<&Bloom>(BlockHeader::VT_LOGS_BLOOM, logs_bloom);
    }
    #[inline]
    pub fn add_difficulty(&mut self, difficulty: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_DIFFICULTY, difficulty);
    }
    #[inline]
    pub fn add_gas_limit(&mut self, gas_limit: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_GAS_LIMIT, gas_limit);
    }
    #[inline]
    pub fn add_gas_used(&mut self, gas_used: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_GAS_USED, gas_used);
    }
    #[inline]
    pub fn add_timestamp(&mut self, timestamp: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_TIMESTAMP, timestamp);
    }
    #[inline]
    pub fn add_extra_data(
        &mut self,
        extra_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockHeader::VT_EXTRA_DATA, extra_data);
    }
    #[inline]
    pub fn add_mix_hash(&mut self, mix_hash: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_MIX_HASH, mix_hash);
    }
    #[inline]
    pub fn add_nonce(&mut self, nonce: u64) {
        self.fbb_.push_slot::<u64>(BlockHeader::VT_NONCE, nonce, 0);
    }
    #[inline]
    pub fn add_base_fee_per_gas(&mut self, base_fee_per_gas: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_BASE_FEE_PER_GAS, base_fee_per_gas);
    }
    #[inline]
    pub fn add_withdrawals_root(&mut self, withdrawals_root: &B256) {
        self.fbb_
            .push_slot_always::<&B256>(BlockHeader::VT_WITHDRAWALS_ROOT, withdrawals_root);
    }
    #[inline]
    pub fn add_total_difficulty(&mut self, total_difficulty: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_TOTAL_DIFFICULTY, total_difficulty);
    }
    #[inline]
    pub fn add_uncles(&mut self, uncles: flatbuffers::WIPOffset<flatbuffers::Vector<'b, B256>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockHeader::VT_UNCLES, uncles);
    }
    #[inline]
    pub fn add_size_(&mut self, size_: &U256) {
        self.fbb_
            .push_slot_always::<&U256>(BlockHeader::VT_SIZE_, size_);
    }
    #[inline]
    pub fn add_withdrawals(
        &mut self,
        withdrawals: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Withdrawal<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BlockHeader::VT_WITHDRAWALS,
            withdrawals,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockHeaderBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BlockHeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BlockHeader<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BlockHeader<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BlockHeader");
        ds.field("number", &self.number());
        ds.field("hash", &self.hash());
        ds.field("parent_hash", &self.parent_hash());
        ds.field("uncles_hash", &self.uncles_hash());
        ds.field("miner", &self.miner());
        ds.field("state_root", &self.state_root());
        ds.field("transactions_root", &self.transactions_root());
        ds.field("receipts_root", &self.receipts_root());
        ds.field("logs_bloom", &self.logs_bloom());
        ds.field("difficulty", &self.difficulty());
        ds.field("gas_limit", &self.gas_limit());
        ds.field("gas_used", &self.gas_used());
        ds.field("timestamp", &self.timestamp());
        ds.field("extra_data", &self.extra_data());
        ds.field("mix_hash", &self.mix_hash());
        ds.field("nonce", &self.nonce());
        ds.field("base_fee_per_gas", &self.base_fee_per_gas());
        ds.field("withdrawals_root", &self.withdrawals_root());
        ds.field("total_difficulty", &self.total_difficulty());
        ds.field("uncles", &self.uncles());
        ds.field("size_", &self.size_());
        ds.field("withdrawals", &self.withdrawals());
        ds.finish()
    }
}
