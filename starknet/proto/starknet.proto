// # Apibara StarkNet Support
syntax = "proto3";

package apibara.starknet.v1alpha1;

import "google/protobuf/timestamp.proto";

// A StarkNet block.
message Block {
  bytes block_hash = 1;
  bytes parent_block_hash = 2;
  uint64 block_number = 3;
  bytes sequencer_address = 4;
  bytes state_root = 5;
  bytes gas_price = 6;
  google.protobuf.Timestamp timestamp = 7;
  string starknet_version = 8;
  repeated Transaction transactions = 9;
}

// Status of a transaction.
enum TransactionStatus {
  TRANSACTION_STATUS_UNSPECIFIED = 0;
  TRANSACTION_STATUS_RECEIVED = 1;
  TRANSACTION_STATUS_PENDING = 2;
  TRANSACTION_STATUS_ACCEPTED_ON_L2 = 3;
  TRANSACTION_STATUS_ACCEPTED_ON_L1 = 4;
  TRANSACTION_STATUS_REJECTED = 5;
}

message Transaction {
  oneof transaction {
    InvokeTransaction invoke = 1;
    DeployTransaction deploy = 2;
    DeclareTransaction declare = 3;
  }
}

message TransactionCommon {
  bytes hash = 1;
  bytes max_fee = 2;
  repeated bytes signature = 3;
  bytes nonce = 4;
}

message InvokeTransaction {
  TransactionCommon common = 1;
  bytes contract_address = 2;
  bytes entry_point_selector = 3;
  repeated bytes calldata = 4;
}

message DeclareTransaction {
  TransactionCommon common = 1;
  bytes class_hash = 2;
  bytes sender_address = 3;
}

message DeployTransaction {
  TransactionCommon common = 1;
}

message TransactionReceipt {
  oneof receipt {
    InvokeTransactionReceipt invoke = 1;
    DeployTransactionReceipt deploy = 2;
    DeclareTransactionReceipt declare = 3;
  }
}

message TransactionReceiptCommon {
  bytes transaction_hash = 1;
  bytes actual_fee = 2;
  TransactionStatus status = 3;
  string status_data = 4;
  bytes block_hash = 5;
  uint64 block_number = 6;
}

message InvokeTransactionReceipt {
  TransactionReceiptCommon common = 1;
  repeated MessageToL1 messages_sent = 2;
  MessageToL2 l1_origin_message = 3;
  repeated Event events = 4;
}

message DeclareTransactionReceipt { TransactionReceiptCommon common = 1; }

message DeployTransactionReceipt { TransactionReceiptCommon common = 1; }

message MessageToL1 {
  bytes to_address = 1;
  repeated bytes payload = 2;
}

message MessageToL2 {
  bytes from_address = 1;
  repeated bytes payload = 2;
}

message Event {
  bytes from_address = 1;
  repeated bytes keys = 2;
  repeated bytes data = 3;
}